\documentclass[aspectratio=43,t]{beamer}
%\documentclass[aspectratio=43,t,handout]{beamer}

\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
%English version FAU Logo
\usepackage[english]{babel}
%German version FAU Logo
%\usepackage[ngerman]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[backend=biber,sorting=none,doi=true,style=ieee]{biblatex}

% Themes:
%  - fau:          FAU theme
%  - fau-med:      MedFak FAU theme
%  - fau-nat:      NatFak FAU theme
%  - fau-phil:     PhilFak FAU theme
%  - fau-rw:       RWFak FAU theme
%  - fau-rw-jura:  RWFak FB Jura FAU theme
%  - fau-rw-wiso:  RWFak FB WISO FAU theme
%  - fau-tf:       TechFak FAU theme
%
% Options:
%  - image:        Cover image on title page
%  - plain:        Plain title page
%  - longtitle:    Title page layout for long title
\usetheme[longtitle]{fau}

% Enable semi-transparent animation preview
\setbeamercovered{transparent}


\lstset{%
  language=C,
  tabsize=2,
  basicstyle=\tt\scriptsize,
  keywordstyle=\color{blue},
  commentstyle=\color{green!50!black},
  stringstyle=\color{red},
  keywords=[2]{computeForce},
  keywords=[3]{reneighbour},
  keywordstyle=[2]{\color{red!100!black}},
  keywordstyle=[3]{\color{green!50!black}},
  numbers=left,
  numbersep=0.5em,
  numberstyle=\tt\tiny
}


\defbibheading{bibliography}{}
\addbibresource[label=primary]{references.bib}
\nocite{*}


% Title, authors, and date
\title[MD Performance Analysis]{Current State of Performance Analysis for Molecular Dynamics}
\author[Rafael Ravedutti L. Machado, Jan Eitzinger]{Rafael Ravedutti L. Machado, Jan Eitzinger}
% English version
\institute[NHR@FAU]{Erlangen National High Performance Computing Center (NHR@FAU)}
% German version
%\institute[Lehrstuhl f\"ur XYZ]{Lehrstuhl f\"ur XYZ, Friedrich-Alexander-Universit\"at Erlangen-N\"urnberg}
\date{\today}
% Set additional logo (overwrites FAU seal)
%\logo{\includegraphics[width=.15\textwidth]{themefau/art/xxx/xxx.pdf}}


\begin{document}
  % Title
  \maketitle

  { % Motivation
    \setbeamertemplate{footline}{}
    \begin{frame}[noframenumbering]{Progress so far:}
        \begin{itemize}
            \item Idea: Exec + Bandwidth + Latency contributions
            \item Gather Benchmark
            \item ASM variants for gather
            \item OSACA Analysis
            \item Changes to MD-Bench:
            \begin{itemize}
                \item AoS layout
                \item Explicit data types
                \item Stubbed force calculation within L1 cache
            \end{itemize}
            \item Assembly Analysis of these different variants
            \begin{itemize}
                \item Three variants
                \item "Prefetching" instructions
                \item Software vs Hardware Gathers
            \end{itemize}
        \end{itemize}
    \end{frame}
  }

  % First, talk about MD-Bench, what it is, what it computes, how it works and etc
  % Talk about our changes: AoS Layout, explicit data types and stubbed force benchmark
  % we want to evaluate the cost of gathers
  % Show structure of the code
  % Show force calculation
  % Talk about the Assembly analysis of MD-Bench
  % Then, talk about the gather-bench, first gather version and md-variants with SoA and AoS
  % Which results to show?

  \begin{frame}[fragile]{MD-Bench}
    \begin{itemize}
      \item \url{https://github.com/RRZE-HPC/MD-Bench}
      \item Sequential re-implementation of miniMD in C
      \item Aim: as simple, clear and understandable as possible
      \item \textbf{Features:}
      \begin{itemize}
        \item Standard test case (Cu FCC lattice)
        \item Lennard Jones potential
        \item Full neighbor lists
      \end{itemize}
      \item \textbf{Runtime Parameters:}
      \begin{itemize}
        \item Number of timesteps
        \item Number of unit cells in x, y and y dimensions 
      \end{itemize}
      \item 4 atoms per unit cell with about 64 neighbors per atom
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{MD-Bench}
    \begin{itemize}
      \item Improvements:
      \begin{itemize}
        \item Stubbed force-calculation to run within L1, L2 and L3 caches
        \item Choose data layouts for atoms during compile-time (AoS vs SoA)
        \item Toggle explicit atom types for simulation.
      \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Simulation Loop}
    \begin{lstlisting}
for(int n = 0; n < param.ntimes; n++) {
  initialIntegrate(&param, &atom);
  if((n + 1) % param.every) {
    updatePbc(&atom, &param);
  } else {
    reneighbour(&param, &atom, &neighbor);
  }
  computeForce(&param, &atom, &neighbor);
  finalIntegrate(&param, &atom);
  if(!((n + 1) % param.nstat) && (n+1) < param.ntimes) {
    computeThermo(n + 1, &param, &atom);
  }
}
    \end{lstlisting}
    \begin{itemize}
      \item Computing the forces is normally the most expensive part!
      \item Building the neighbor lists can also take a considerable fraction of the simulation time, specially when:
      \begin{itemize}
        \item Force calculation time gets smaller (simpler potential to compute, optimizations)
        \item Rebuilding frequency gets smaller!
      \end{itemize}
      \item \textbf{For now, we just focus on the force computation!}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Force Computation Loop}
    \begin{lstlisting}[basicstyle=\tt\tiny]
for(int i = 0; i < Nlocal; i++) {
  neighs = &neighbor->neighbors[i * neighbor->maxneighs];
  int numneighs = neighbor->numneigh[i];
  MD_FLOAT xtmp = atom_x(i);
  MD_FLOAT ytmp = atom_y(i);
  MD_FLOAT ztmp = atom_z(i);
  MD_FLOAT fix = 0;
  MD_FLOAT fiy = 0;
  MD_FLOAT fiz = 0;

  for(int k = 0; k < numneighs; k++) {
    int j = neighs[k];
    MD_FLOAT delx = xtmp - atom_x(j);
    MD_FLOAT dely = ytmp - atom_y(j);
    MD_FLOAT delz = ztmp - atom_z(j);
    MD_FLOAT rsq = delx * delx + dely * dely + delz * delz;
    if(rsq < cutforcesq) {
      MD_FLOAT sr2 = 1.0 / rsq;
      MD_FLOAT sr6 = sr2 * sr2 * sr2 * sigma6;
      MD_FLOAT force = 48.0 * sr6 * (sr6 - 0.5) * sr2 * epsilon;
      fix += delx * force;
      fiy += dely * force;
      fiz += delz * force;
    }
  }

  fx[i] += fix;
  fy[i] += fiy;
  fz[i] += fiz;
}
    \end{lstlisting}
  \end{frame}

  \begin{frame}[fragile]{Neighbors Loop}
    \begin{lstlisting}
for(int k = 0; k < numneighs; k++) {
  int j = neighs[k];
  MD_FLOAT delx = xtmp - atom_x(j);
  MD_FLOAT dely = ytmp - atom_y(j);
  MD_FLOAT delz = ztmp - atom_z(j);
  MD_FLOAT rsq = delx * delx + dely * dely + delz * delz;
  if(rsq < cutforcesq) {
    MD_FLOAT sr2 = 1.0 / rsq;
    MD_FLOAT sr6 = sr2 * sr2 * sr2 * sigma6;
    MD_FLOAT force = 48.0 * sr6 * (sr6 - 0.5) * sr2 * epsilon;
    fix += delx * force;
    fiy += dely * force;
    fiz += delz * force;
  }
}
    \end{lstlisting}
    \begin{itemize}
      \item To vectorize the code for \emph{k}, gathering of the data is required
      \item Two possibilities: Hardware or Software gathers
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Stubbed force calculation}
  \end{frame}

  \begin{frame}[fragile]{Assembly Analysis:}
    \begin{itemize}
      \item Intel compiler (ICC) v19.0.5.281 Build 20190815
      \item Flags: \texttt{-S -masm=intel -D\_GNU\_SOURCE -DAOS -DPRECISION=2 -DALIGNMENT=64 -restrict -Ofast -xCORE-AVX 512 -qopt-zmm-usage=high -o ICC/force.s}
      \item For AVX512, all kernels with zmm registers and gather instructions
      \item Three kernel variants (Consider \texttt{rmng\_neighs = numneighs - k}):
      \begin{itemize}
        \item \texttt{rmng\_neighs < 8:} last iteration, vectors are not fulfilled
        \item \texttt{rmng\_neighs in ]8, 1200]:} with mov+lea instructions (prefetching?), L1 case? 1200 * 3 * 8 = 28.8kB, L1 cache size is 32kB on Cascade Lake
        \item \texttt{rmng\_neighs >= 1200:} no mov+lea instructions
      \end{itemize}
      \item We will focus on the \texttt{rmng\_neighs in ]8, 1200]} variant
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Assembly Analysis:}
    \begin{lstlisting}[basicstyle=\tt\tiny]
vmovdqu   ymm3, YMMWORD PTR [r13+rbx*4]   # ymm3 <- neighs[k]
vpaddd    ymm4, ymm3, ymm3                # ymm4 <- neighs[k] * 2
vpaddd    ymm3, ymm3, ymm4                # ymm3 <- neighs[k] * 3
# ---------------- mov+lea instructions (prefetching?) ------------------
mov       r10d, DWORD PTR [r13+rbx*4]     # r10d <- neighs[k]
mov       r9d, DWORD PTR [4+r13+rbx*4]    # r9d <- neighs[k + 1]
mov       r8d, DWORD PTR [8+r13+rbx*4]    # r8d <- neighs[k + 2]
mov       esi, DWORD PTR [12+r13+rbx*4]   # esi <- neighs[k + 3]
lea       r10d, DWORD PTR [r10+r10*2]     # r10d <- neighs[k] * 3
mov       ecx, DWORD PTR [16+r13+rbx*4]   # ecx <- neighs[k + 4]
lea       r9d, DWORD PTR [r9+r9*2]        # r9d <- neighs[k + 1] * 3
mov       edx, DWORD PTR [20+r13+rbx*4]   # edx <- neighs[k + 5]
lea       r8d, DWORD PTR [r8+r8*2]        # r8d <- neighs[k + 2] * 3
mov       eax, DWORD PTR [24+r13+rbx*4]   # edx <- neighs[k + 6]
lea       esi, DWORD PTR [rsi+rsi*2]      # esi <- neighs[k + 3] * 3
mov       r15d, DWORD PTR [28+r13+rbx*4]  # edx <- neighs[k + 7]
lea       ecx, DWORD PTR [rcx+rcx*2]      # ecx <- neighs[k + 4] * 3
lea       edx, DWORD PTR [rdx+rdx*2]      # edx <- neighs[k + 5] * 3
lea       eax, DWORD PTR [rax+rax*2]      # eax <- neighs[k + 6] * 3
lea       r15d, DWORD PTR [r15+r15*2]     # r15d <- neighs[k + 7] * 3
# ---------------- end of mov+lea instructions --------------------------
vpcmpeqb  k1, xmm0, xmm0                  # k1 <- [true for all elements]
vpcmpeqb  k2, xmm0, xmm0                  # k2 <- [true for all elements]
vpcmpeqb  k3, xmm0, xmm0                  # k3 <- [true for all elements]
vpxord    zmm4, zmm4, zmm4                # zmm4 <- 0.0
vpxord    zmm17, zmm17, zmm17             # zmm17 <- 0.0
vpxord    zmm18, zmm18, zmm18             # zmm18 <- 0.0
vgatherdpd zmm4{k1}, QWORD PTR [16+rdi+ymm3*8] # zmm4 <- atom->x[j * 3 + 2]
vgatherdpd zmm17{k2}, QWORD PTR [8+rdi+ymm3*8] # zmm17 <- atom->x[j * 3 + 1]
vgatherdpd zmm18{k3}, QWORD PTR [rdi+ymm3*8]   # zmm18 <- atom->x[j * 3]
    \end{lstlisting}
  \end{frame}

  \begin{frame}[fragile]{Assembly Analysis:}
    When removing mov+lea instructions, performance is better on Cascade Lake:
    \begin{verbatim}
    With lea+mov:
    TOTAL 9.30s FORCE 4.81s NEIGH 4.25s REST 0.24s

    Without lea+mov:
    TOTAL 8.95s FORCE 4.43s NEIGH 4.28s REST 0.24s
    \end{verbatim}
  \end{frame}

  \begin{frame}[fragile]{OSACA Analysis}
  \end{frame}

  \begin{frame}[fragile]{Running Internal Loop several times}
  \end{frame}

  \begin{frame}[fragile]{Cycles when running internal loop several time}
  \end{frame}

  \begin{frame}[fragile]{Conclusions about Texec}
  \end{frame}

  \begin{frame}[fragile]{gather-bench}
  \end{frame}

  % List example
  %\begin{frame}[fragile]{Capturing expressions}
  %  \begin{itemize}
  %      \item Operator overloading
  %      \item Vector operations are easily expressed
  %  \end{itemize}
  %\end{frame}

  % Code example
  %\begin{frame}[fragile]{Capturing expressions}
  %  \begin{lstlisting}
  %  \end{lstlisting}
  %\end{frame}

  % Image example
  %\begin{frame}{Experimental Results}
  %  \begin{block}{Weak Scaling Perfomance}
  %    \includegraphics[width=9cm]{results/weak_scaling.png}
  %  \end{block}
  %\end{frame}

  { % Questions?
    %\setbeamertemplate{footline}{}
    %\begin{frame}[c,noframenumbering]
    %  \begin{center}
    %    Thank you for listening.\\
    %    {\bf Any questions?}
    %  \end{center}
    %\end{frame}

    % References
    %\section*{References}
    %\begin{frame}[allowframebreaks,noframenumbering]{References}
    %  \printbibliography
    %\end{frame}
  }
\end{document}

